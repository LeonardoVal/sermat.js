{"version":3,"sources":["../src/__prologue__.js","../src/registry.js","../src/serialization.js","../src/materialization.js","../src/utilities.js","../src/constructions.js","../src/wrapup.js","../src/__epilogue__.js"],"names":["__init__","member","obj","id","value","flags","Object","defineProperty","writable","configurable","enumerable","_modifier","defaultValue","hasOwnProperty","_getProto","getPrototypeOf","__proto__","_setProto","setPrototypeOf","proto","_assign","assign","objTo","objFrom","keys","forEach","k","r","_isArray","Array","isArray","FUNCTION_ID_RE","ID_REGEXP","INVALID_ID_RE","identifier","type","must","__SERMAT__","name","exec","Error","record","this","registry","register","spec","trim","serializer","serializeWithConstructor","bind","materializer","materializeWithConstructor","global","include","test","freeze","CONSTRUCTIONS","remove","arg","inheritable","map","c","exclude","BASIC_MODE","REPEAT_MODE","BINDING_MODE","CIRCULAR_MODE","serialize","modifiers","sermat","mode","pretty","onUndefined","autoInclude","useConstructions","climbPrototypes","visited","parents","_colon","_equal","serializeValue","eol","prototype","v","call","serializeUndefined","serializeString","f","rec","serializeObject","serializeFunction","str","JSON","stringify","indexOf","TypeError","i","output","push","eol2","serializeElements","serializeArray","objProto","elems","constructor","args","pop","_comma","len","length","construct","SyntaxError","RE_IGNORABLES","RE_NUM","RE_STR","RE_STR2","RE_CONS","RE_ID","RE_BIND","RE_SYMBOLS","RE_EOL","LEXER","RegExp","source","LEX_EOI","LEX_NUM","LEX_STR","LEX_STR2","LEX_CONS","LEX_ID","LEX_BIND","LEX_COMMA","LEX_COLON","LEX_OBRACKET","LEX_CBRACKET","LEX_OBRACE","LEX_CBRACE","LEX_OPAREN","LEX_CPAREN","LEX_EQUAL","materialize","input","offset","token","text","bindings","nextToken","tokens","substr","error","charAt","msg","line","lineStart","replace","match","pos","shift","expected","parseValue","t","eval","parseArray","parseObject","parseBind","parseConstruction","array","parseElements","ReferenceError","cons","result","serializeAsProperties","properties","ownProperties","fromArray","comps","split","create","apply","mat","ser","clone","cloned","cloneValue","cloneObject","clonedObj","clonedIdx","clonedArgs","hashCode","hashCodes","hashValue","charCodeAt","hashObject","hash","hashIndex","hashes","sort","x","y","signature","arguments","checkSignature","regexp","types","concat","FUNCTION_RE","serialize_Error","message","stack","materializer_Error","Sermat","params","__registry__","__modifiers__","Boolean","valueOf","Number","String","raise","Date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","UTC","Function","materialize_Function","ParseError","EvalError","RangeError","URIError","__members__","m","__SINGLETON__"],"mappings":"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","file":"sermat.min.js","sourcesContent":["/** Library wrapper and layout.\r\n*/\r\nfunction __init__() { \"use strict\";\r\n\t\r\n/** Utility functions used in the library.\r\n*/\r\n\tfunction member(obj, id, value, flags) {\r\n\t\tflags = flags|0;\r\n\t\tObject.defineProperty(obj, id, {\r\n\t\t\tvalue: value,\r\n\t\t\twritable: flags & 4, \r\n\t\t\tconfigurable: flags & 2, \r\n\t\t\tenumerable: flags & 1\r\n\t\t});\r\n\t}\r\n\r\n\tfunction _modifier(obj, id, defaultValue) {\r\n\t\treturn obj && obj.hasOwnProperty(id) ? obj[id] : defaultValue;\r\n\t}\r\n\t\r\n\tvar _getProto = Object.getPrototypeOf || function _getProto(obj) {\r\n\t\t\treturn obj.__proto__;\r\n\t\t},\r\n\t\t_setProto = Object.setPrototypeOf || function _setProto(obj, proto) {\r\n\t\t\tobj.__proto__ = proto;\r\n\t\t\treturn obj;\r\n\t\t},\r\n\t\t_assign = Object.assign || function _assign(objTo, objFrom) {\r\n\t\t\tObject.keys(objFrom).forEach(function (k) {\r\n\t\t\t\tobjTo[k] = objFrom[k];\r\n\t\t\t});\r\n\t\t\treturn r;\r\n\t\t},\r\n\t\t_isArray = Array.isArray //TODO Polyfill?\r\n\t;\r\n/** See `__epilogue__.js`.\r\n*/","/** ## Registry ####################################################################################\r\n\r\nSermat allows an extensible syntax to write and read instances of custom _classes_. The syntax \r\nressembles a function call in Javascript. For example:\r\n\r\n```\r\nRegExp(\"\\d+\", \"g\")\r\nDate(1999,12,31,23,59,59,999)\r\n```\r\n\r\nThese are called _constructions_. In order to use them, the custom class' constructor has to be \r\nregistered with two functions: serializer and materializer. The serializer calculates an array of\r\nvalues that will allow to rebuild (i.e. materialize) the instance being serialized (i.e. \r\n_stringified_). The materializer creates a new instance based on the previously serialized values.\r\n\r\nAll constructions use a name to identify the type's custom serializer and materializer. Sermat must \r\nbe able to infer this name from the constructor function of the type. By default the name of the \r\nconstructor function is used, but this can be overriden by setting a `__SERMAT__` property of the \r\nfunction.\r\n*/\r\nvar FUNCTION_ID_RE = /^\\s*function\\s+([\\w\\$]+)/,\r\n\tID_REGEXP = /^[a-zA-Z_][a-zA-Z0-9_]*(?:[\\.-][a-zA-Z0-9_]+)*$/,\r\n\tINVALID_ID_RE = /^(true|false|null|undefined|NaN|Infinity|\\$[\\w\\$]*)$/;\r\nfunction identifier(type, must) {\r\n\tvar id = (type.__SERMAT__ && type.__SERMAT__.identifier)\r\n\t\t|| type.name\r\n\t\t|| (FUNCTION_ID_RE.exec(type +'') || [])[1];\r\n\tif (!id && must) {\r\n\t\tthrow new Error(\"Sermat.identifier: Could not found id for type \"+ type +\"!\");\r\n\t}\r\n\treturn id;\r\n}\r\n\r\n/** A `record` for a construction can be obtained using its identifier or the constructor function\r\nof the type.\r\n*/\r\nfunction record(type) {\r\n\tvar id = typeof type === 'function' ? identifier(type, true) : type +'';\r\n\treturn this.registry[id];\r\n}\r\n\r\n/** The registry spec for every custom construction usually has four components: an `identifier`, a \r\n`type` constructor function, a `serializer` function and a `materializer` function. A `global` flag\r\ncan also be provided, and if true causes the construction to be added to the `Sermat.CONSTRUCTIONS` \r\nglobal registry.\r\n\r\nThe identifier can be inferred from the constructor function. If a materializer function is not \r\nspecified, it is assumed the serialization is equal to the arguments with which the constructor has \r\nto be called to recreate the instance. So, a default materializer is created, which calls the \r\nconstructor with the list of values in the text.\r\n*/\r\nfunction register(registry, spec) {\r\n\tif (typeof spec.type !== 'function') {\r\n\t\tthrow new Error(\"Sermat.register: No constructor found for type (\"+ spec +\")!\");\r\n\t}\r\n\tspec = {\r\n\t\ttype: spec.type,\r\n\t\tidentifier: (spec.identifier || identifier(spec.type, true)).trim(),\r\n\t\tserializer: spec.serializer || serializeWithConstructor.bind(this, spec.type),\r\n\t\tmaterializer: spec.materializer || materializeWithConstructor.bind(this, spec.type),\r\n\t\tglobal: !!spec.global,\r\n\t\tinclude: spec.include\r\n\t};\r\n\tvar id = spec.identifier;\r\n\tif (INVALID_ID_RE.test(id)) {\r\n\t\tthrow new Error(\"Sermat.register: Invalid identifier '\"+ id +\"'!\");\r\n\t} else if (registry.hasOwnProperty(id)) {\r\n\t\tthrow new Error(\"Sermat.register: Construction '\"+ id +\"' is already registered!\");\r\n\t} else if (typeof spec.serializer !== 'function') {\r\n\t\tthrow new Error(\"Sermat.register: Serializer for '\"+ id +\"' is not a function!\");\r\n\t} else if (typeof spec.materializer !== 'function') {\r\n\t\tthrow new Error(\"Sermat.register: Materializer for '\"+ id +\"' is not a function!\");\r\n\t}\r\n\tObject.freeze(spec);\r\n\tregistry[id] = spec;\r\n\tif (spec.global && !CONSTRUCTIONS[id]) {\r\n\t\tCONSTRUCTIONS[id] = spec;\r\n\t}\r\n\tif (spec.include) {\r\n\t\tthis.include(spec.include);\r\n\t}\r\n\treturn spec;\r\n}\r\n\r\n/** A registered construction can be removed with the `remove` method giving its identifier.\r\n*/\r\nfunction remove(registry, id) {\r\n\tif (!registry.hasOwnProperty(id)) {\r\n\t\tthrow new Error(\"Sermat.remove: A construction for '\"+ id +\"' has not been registered!\");\r\n\t}\r\n\tvar r = registry[id];\r\n\tdelete registry[id];\r\n\treturn r;\r\n}\r\n\r\n/** The `include` method is a more convenient and flexible way of registering custom types. If a \r\nname (i.e. a string) is provided, the corresponding entry in `Sermat.CONSTRUCTIONS` will be added.\r\nIf a constructor function is given and it has a `__SERMAT__` member with the type's definitions, \r\nthen this will be registered. An array with a combination of the previous two types registers all\r\nmembers. Lastly, an spec record can be used as well. The method tries not to raise errors. \r\n*/\r\nfunction include(arg) {\r\n\tvar spec = null;\r\n\tswitch (typeof arg) {\r\n\t\tcase 'function': {\r\n\t\t\tspec = this.record(arg);\r\n\t\t\tif (!spec && arg.__SERMAT__) {\r\n\t\t\t\tspec = arg.__SERMAT__;\r\n\t\t\t\tif (!arg.hasOwnProperty('__SERMAT__') && !spec.inheritable) { // Inherited __SERMAT__\r\n\t\t\t\t\tspec = Object.assign({}, spec);\r\n\t\t\t\t\tspec.identifier = this.identifier(arg, true);\r\n\t\t\t\t}\r\n\t\t\t\tspec.type = arg;\r\n\t\t\t\tspec = this.register(spec);\r\n\t\t\t}\r\n\t\t\treturn spec;\r\n\t\t}\r\n\t\tcase 'string': {\r\n\t\t\tspec = this.record(arg);\r\n\t\t\tif (!spec && CONSTRUCTIONS[arg]) {\r\n\t\t\t\tspec = this.register(CONSTRUCTIONS[arg]);\r\n\t\t\t}\r\n\t\t\treturn spec;\r\n\t\t}\r\n\t\tcase 'object': {\r\n\t\t\tif (Array.isArray(arg)) {\r\n\t\t\t\treturn arg.map((function (c) {\r\n\t\t\t\t\treturn this.include(c);\r\n\t\t\t\t}).bind(this));\r\n\t\t\t} else if (typeof arg.type === 'function') {\r\n\t\t\t\treturn this.record(arg.identifier || arg.type) || this.register(arg);\r\n\t\t\t} else if (arg && arg.__SERMAT__ && arg.__SERMAT__.include) {\r\n\t\t\t\treturn this.include(arg.__SERMAT__.include);\r\n\t\t\t}\r\n\t\t}\r\n\t\tdefault: throw new Error(\"Sermat.include: Could not include (\"+ arg +\")!\");\r\n\t}\r\n}\r\n\r\n/** The `exclude` method is also a convenient way of removing type registrations. Returns the amount\r\nof registrations actually removed.\r\n*/\r\nfunction exclude(arg) {\r\n\tswitch (typeof arg) {\r\n\t\tcase 'string': {\r\n\t\t\tif (this.record(arg)) {\r\n\t\t\t\tthis.remove(arg);\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tcase 'function': {\r\n\t\t\treturn this.exclude(identifier(arg));\r\n\t\t}\r\n\t\tcase 'object': {\r\n\t\t\tif (Array.isArray(arg)) {\r\n\t\t\t\tvar r = 0;\r\n\t\t\t\targ.forEach((function (c) {\r\n\t\t\t\t\tr += this.exclude(c);\r\n\t\t\t\t}).bind(this));\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\t\t}\r\n\t\tdefault: throw new Error(\"Sermat.exclude: Could not exclude (\"+ arg +\")!\");\r\n\t}\r\n}","/** ## Serialization ###############################################################################\r\n\r\nSerialization is similar to JSON's `stringify` method. The method takes a data structure and\r\nproduces a text representation of it. As a second argument the function takes a set of modifiers of\r\nthe functions behaviour. The most important one is perhaps `mode`.\r\n*/\r\n\r\n/** There are four modes of operation:\r\n\r\n+ `BASIC_MODE`: No object inside the given value is allowed to be serialized more than once.\r\n\r\n+ `REPEATED_MODE`: If while serializing any object inside the given value is visited more than once,\r\n\tits serialization is repeated every time. Still, circular references are not allowed. This is\r\n\tanaloguos to `JSON.stringify`'s behaviour.\r\n\r\n+ `BINDING_MODE`: Every object inside the given value is given an identifier. If any one of these\r\n\tis visited twice or more, a reference to the first serialization is generated using this\r\n\tidentifier. The materialization actually reuses instances, though circular references are still\r\n\tforbidden.\r\n\r\n+ `CIRCULAR_MODE`: Similar to `BINDING_MODE`, except that circular references are allowed. This\r\n\tstill depends on the constructions' materializers supporting circular references.\r\n*/\r\nvar BASIC_MODE = 0,\r\n\tREPEAT_MODE = 1,\r\n\tBINDING_MODE = 2,\r\n\tCIRCULAR_MODE = 3;\r\n\r\n/** Serialization method can be called as `serialize` or `ser`. Besides the `mode`, other modifiers\r\nof the serialization include:\r\n\r\n+ `onUndefined=TypeError`: If it is a constructor for a subtype of `Error`, it is used to throw an\r\n\texception when an undefined is found. If it is other type function, it is used as a callback.\r\n\tElse the value of this modifier is serialized as in place of the undefined value, and if it is\r\n\tundefined itself the `undefined` string is used.\r\n\r\n+ `autoInclude`: If `true` forces the registration of types found during the serialization, but not\r\n\tin the construction registry.\r\n\r\n+ `useConstructions=true`: If `false` constructions (i.e. custom serializations) are not used, and\r\n\tall objects are treated as literals (the same way JSON does). It is `true` by default.\r\n\r\n+ `climbPrototypes=true`: If `true`, every time an object's constructor is not an own property of\r\n\tits prototype, its prototype will be serialized as the `__proto__` property.\r\n\r\n+ `pretty=false`: If `true` the serialization is formatted with whitespace to make it more readable.\r\n*/\r\n//TODO Allow modifiers.bindings.\r\nfunction serialize(obj, modifiers) {\r\n\tvar sermat = this,\r\n\t\tmode = _modifier(modifiers, 'mode', this.modifiers.mode),\r\n\t\tpretty = _modifier(modifiers, 'pretty', this.modifiers.pretty),\r\n\t\tonUndefined = _modifier(modifiers, 'onUndefined', this.modifiers.onUndefined),\r\n\t\tautoInclude = _modifier(modifiers, 'autoInclude', this.modifiers.autoInclude),\r\n\t\tuseConstructions = _modifier(modifiers, 'useConstructions', this.modifiers.useConstructions),\r\n\t\tclimbPrototypes = _modifier(modifiers, 'climbPrototypes', this.modifiers.climbPrototypes),\r\n\t\tvisited = mode === REPEAT_MODE ? null : [],\r\n\t\tparents = [],\r\n\t\t_colon = pretty ? ' : ' : ':',\r\n\t\t_equal = pretty ? ' = ' : '=';\r\n\r\n\tfunction serializeValue(value, eol) {\r\n\t\tswitch (typeof value) {\r\n\t\t\tcase 'undefined': return serializeUndefined();\r\n\t\t\tcase 'boolean':\r\n\t\t\tcase 'number': return value +'';\r\n\t\t\tcase 'string': return serializeString(value);\r\n\t\t\tcase 'function': return serializeFunction(value, eol);\r\n\t\t\tcase 'object': return serializeObject(value, eol);\r\n\t\t}\r\n\t}\r\n\r\n\t/** The `undefined` special value can be handled in many ways, depending on the `onUndefined`\r\n\tmodifier. If it is a constructor for a subtype of `Error`, it is used to throw an exception. If\r\n\tit other type function, it is used as a callback. Else the value is serialized as it is, even if\r\n\tit is `undefined` itself.\r\n\t*/\r\n\tfunction serializeUndefined() {\r\n\t\tswitch (typeof onUndefined) {\r\n\t\t\tcase 'undefined':\r\n\t\t\t\treturn 'undefined';\r\n\t\t\tcase 'function': {\r\n\t\t\t\tif (onUndefined.prototype instanceof Error) {\r\n\t\t\t\t\tthrow new onUndefined(\"Sermat.ser: Cannot serialize undefined value!\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar v = onUndefined.call(null); // Use the given function as callback.\r\n\t\t\t\t\treturn (typeof v === 'undefined') ? 'undefined' : serializeValue(v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdefault: return serializeValue(onUndefined);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction serializeString(str) {\r\n\t\treturn JSON.stringify(str);\r\n\t}\r\n\r\n\tfunction serializeFunction(f, eol) {\r\n\t\tvar rec = sermat.identifier(f, false) ? sermat.record(f) : null;\r\n\t\tif (rec) {\r\n\t\t\treturn '$'+ rec.identifier;\r\n\t\t} else {\r\n\t\t\t// Continue to object, using Function's serializer if it is registered.\r\n\t\t\treturn serializeObject(f, eol);\r\n\t\t}\r\n\t}\r\n\r\n\t/** During object serialization two lists are kept. The `parents` list holds all the ancestors\r\n\tof the current object. This is useful to check for circular references. The `visited` list holds\r\n\tall previously serialized objects, and is used to check for repeated references and bindings.\r\n\t*/\r\n\tfunction serializeObject(obj, eol) {\r\n\t\tif (!obj) {\r\n\t\t\treturn 'null';\r\n\t\t} else if (parents.indexOf(obj) >= 0 && mode !== CIRCULAR_MODE) {\r\n\t\t\tthrow new TypeError(\"Sermat.ser: Circular reference detected!\");\r\n\t\t}\r\n\t\tvar output = '',\r\n\t\t\ti, len;\r\n\t\t/** If `visited` is `null`, means the mode is `REPEAT_MODE` and repeated references do\r\n\t\tnot have to be checked. This is only an optimization.\r\n\t\t*/\r\n\t\tif (visited) {\r\n\t\t\ti = visited.indexOf(obj);\r\n\t\t\tif (i >= 0) {\r\n\t\t\t\tif (mode & BINDING_MODE) {\r\n\t\t\t\t\treturn '$'+ i;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new TypeError(\"Sermat.ser: Repeated reference detected!\");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ti = visited.push(obj) - 1;\r\n\t\t\t\tif (mode & BINDING_MODE) {\r\n\t\t\t\t\toutput = '$'+ i + _equal;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tparents.push(obj);\r\n\t\tvar eol2 = eol && eol +'\\t';\r\n\t\tif (_isArray(obj)) { // Arrays.\r\n\t\t\toutput += serializeArray(obj, eol, eol2);\r\n\t\t} else {\r\n\t\t\t/** An object literal is serialized as a sequence of key-value pairs separated by commas\r\n\t\t\t\tbetween braces. Each pair is joined by a colon. This is the same syntax that\r\n\t\t\t\tJavascript's object literals follow.\r\n\t\t\t*/\r\n\t\t\tvar objProto = _getProto(obj),\r\n\t\t\t\telems = '';\r\n\t\t\tif (obj.constructor === Object || !useConstructions ||\r\n\t\t\t\t\tclimbPrototypes && !objProto.hasOwnProperty('constructor')) {\r\n\t\t\t\telems = serializeElements(obj, eol, eol2);\r\n\t\t\t/** The object's prototype not having its constructor as an own property is understood\r\n\t\t\t\tas an indication that the prototype has been altered, and hence needs to be\r\n\t\t\t\tserialized. If the `climbPrototypes` modifier is `true`, the object's prototype is\r\n\t\t\t\tadded to the serialization as the `__proto__` property.\r\n\t\t\t*/\r\n\t\t\t\tif (climbPrototypes && !objProto.hasOwnProperty('constructor')) {\r\n\t\t\t\t\telems += (elems ? ','+ eol2 : '') +'__proto__'+ _colon\r\n\t\t\t\t\t\t+ serializeObject(objProto, eol);\r\n\t\t\t\t}\r\n\t\t\t\toutput += '{'+ eol2 + elems + eol +'}';\r\n\t\t\t} else {\r\n\t\t\t/** Constructions is the term used to custom serializations registered by the user for\r\n\t\t\t\tspecific types. They are serialized as an identifier, followed by a sequence of\r\n\t\t\t\tvalues \tseparated by commas between parenthesis. It ressembles a call to a function\r\n\t\t\t\tin Javascript.\r\n\t\t\t*/\r\n\t\t\t\tvar record = sermat.record(obj.constructor)\r\n\t\t\t\t\t|| autoInclude && sermat.include(obj.constructor);\r\n\t\t\t\tif (!record) {\r\n\t\t\t\t\tthrow new TypeError(\"Sermat.ser: Unknown type \\\"\"+\r\n\t\t\t\t\t\tsermat.identifier(obj.constructor) +\"\\\"!\");\r\n\t\t\t\t}\r\n\t\t\t\tvar args = record.serializer.call(sermat, obj),\r\n\t\t\t\t\tid = record.identifier;\r\n\t\t\t\tif (Array.isArray(args)) {\r\n\t\t\t\t\toutput += (ID_REGEXP.exec(id) ? id : serializeString(id)) +'('+ eol2\r\n\t\t\t\t\t\t+ serializeElements(args, eol, eol2) + eol +')';\r\n\t\t\t\t} else {\r\n\t\t\t\t\toutput += serializeObject(args, eol);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tparents.pop();\r\n\t\treturn output;\r\n\t}\r\n\r\n\tfunction serializeArray(obj, eol, eol2) {\r\n\t\t/** An array is serialized as a sequence of values separated by commas between brackets,\r\n\t\tas arrays are written in plain Javascript.\r\n\t\t*/\r\n\t\treturn '['+ eol2 + serializeElements(obj, eol, eol2) + eol +']';\r\n\t}\r\n\r\n\tfunction serializeElements(obj, eol, eol2) {\r\n\t\tvar output = '',\r\n\t\t\t_comma = ','+ eol2,\r\n\t\t\ti = 0,\r\n\t\t\tisArray = Array.isArray(obj),\r\n\t\t\tlen = isArray ? obj.length : 0;\r\n\t\tif (len > 0) {\r\n\t\t\toutput += serializeValue(obj[i], eol2);\r\n\t\t\tfor (i++; i < len; i++) {\r\n\t\t\t\toutput += _comma + serializeValue(obj[i], eol2);\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject.keys(obj).forEach(function (k) {\r\n\t\t\tif (isArray && (k|0) - k === 0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (i > 0) {\r\n\t\t\t\toutput += _comma;\r\n\t\t\t}\r\n\t\t\toutput += (ID_REGEXP.exec(k) ? k : serializeString(k)) + _colon +\r\n\t\t\t\tserializeValue(obj[k], eol2);\r\n\t\t\ti++;\r\n\t\t});\r\n\t\treturn output;\r\n\t}\r\n\r\n\treturn serializeValue(obj, pretty ? '\\n' : '');\r\n}\r\n","/** ## Materialization #############################################################################\r\n\r\nThe `materialize` method is similar to JSON's `parse` method. It takes text and parses it to produce\r\nthe data structure it represents.\r\n*/\r\n\r\n/** The `construct` method seeks for a materializer for the given identifier and calls it.\r\n*/\r\nfunction construct(id, obj, args) {\r\n\tvar record = this.record(id);\r\n\tif (record) {\r\n\t\treturn record.materializer.call(this, obj, args);\r\n\t} else {\r\n\t\tthrow new SyntaxError(\"Sermat.construct: Cannot materialize type '\"+ id +\"'\");\r\n\t}\r\n}\r\n\r\nvar RE_IGNORABLES = /(?:\\s|\\/\\*(?:[^*]*|\\n|\\*+[^\\/])*\\*+\\/)*/,\r\n\tRE_NUM = /[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?|[+-]Infinity/,\r\n\tRE_STR = /\\\"(?:[^\\\\\\\"\\r\\n]|\\\\[^\\r\\n])*\\\"/,\r\n\tRE_STR2 = /(?:`(?:[^`]|[\\r\\n])*`)+/,\r\n\tRE_CONS = /(?:true|false|null|undefined|Infinity|NaN)\\b/,\r\n\tRE_ID = /[a-zA-Z_]+(?:[.-]?[a-zA-Z0-9_])*/,\r\n\tRE_BIND = /\\$(?:[.-]?[a-zA-Z0-9_])*/,\r\n\tRE_SYMBOLS = /[,:[\\]{}()=]/,\r\n\tRE_EOL = /\\r\\n?|\\n/g,\r\n\tLEXER = new RegExp('^'+ RE_IGNORABLES.source +'(?:'+\r\n\t\t'('+ RE_NUM.source \r\n\t\t+')|('+ RE_STR.source\r\n\t\t+')|('+ RE_STR2.source\r\n\t\t+')|('+ RE_CONS.source\r\n\t\t+')|('+ RE_ID.source\r\n\t\t+')|('+ RE_BIND.source\r\n\t\t+')|('+ RE_SYMBOLS.source \r\n\t\t+')|$)'),\r\n\tLEX_EOI = 0,\r\n\tLEX_NUM = 1,\r\n\tLEX_STR = 2,\r\n\tLEX_STR2 = 3,\r\n\tLEX_CONS = 4,\r\n\tLEX_ID = 5,\r\n\tLEX_BIND = 6,\r\n\t// SYMBOLS\r\n\tLEX_COMMA    = 7,\r\n\tLEX_COLON    = 8,\r\n\tLEX_OBRACKET = 9,\r\n\tLEX_CBRACKET = 10,\r\n\tLEX_OBRACE   = 11,\r\n\tLEX_CBRACE   = 12,\r\n\tLEX_OPAREN   = 13,\r\n\tLEX_CPAREN   = 14,\r\n\tLEX_EQUAL    = 15;\r\n\t\r\nfunction materialize(source, modifiers) {\r\n\tvar input = source,\r\n\t\toffset = 0,\r\n\t\ttoken = -1, text = '',\r\n\t\tbindings = modifiers && modifiers.bindings || {},\r\n\t\tsermat = this;\r\n\r\n\tfunction nextToken() {\r\n\t\tvar tokens, len, i, chr;\r\n\t\tif (tokens = LEXER.exec(input)) {\r\n\t\t\t//console.log(tokens);//LOG Uncomment for debugging.\r\n\t\t\tlen = tokens[0].length;\r\n\t\t\tinput = input.substr(len);\r\n\t\t\toffset += len;\r\n\t\t\ttext = '';\r\n\t\t\tfor (i = 1, len = tokens.length - 1; i < len; i++) {\r\n\t\t\t\tif (tokens[i]) {\r\n\t\t\t\t\ttext = tokens[i];\r\n\t\t\t\t\treturn token = i;\r\n\t\t\t\t}\r\n\t\t\t} \r\n\t\t\ttext = tokens[i];\r\n\t\t\ttoken = ',:[]{}()='.indexOf(text);\r\n\t\t\treturn token = token < 0 ? LEX_EOI : token + LEX_COMMA;\r\n\t\t}\r\n\t\terror('Invalid character \"'+ input.charAt(0) +'\"');\r\n\t}\r\n\t\r\n\tfunction error(msg) {\r\n\t\tmsg = msg || \"Parse error\";\r\n\t\toffset -= text.length;\r\n\t\tvar line = 0, lineStart = 0;\r\n\t\tsource.substr(0, offset).replace(RE_EOL, function (match, pos) {\r\n\t\t\tlineStart = pos + match.length;\r\n\t\t\tline++;\r\n\t\t\treturn '';\r\n\t\t});\r\n\t\tthrow new SyntaxError(\"Sermat.mat: \"+ msg +\" at line \"+ (line + 1) +\" column \"+ \r\n\t\t\t(offset - lineStart) +\" (offset \"+ (offset + 1) +\")!\");\r\n\t}\r\n\r\n\tfunction shift(expected) {\r\n\t\tif (token !== expected) {\r\n\t\t\terror(\"Parse error. Expected <\"+ expected +\"> but got <\"+ (text || token) +\">\");\r\n\t\t}\r\n\t\tnextToken();\r\n\t}\r\n\r\n\tfunction parseValue() {\r\n\t\tvar t = text;\r\n\t\tswitch (token) {\r\n\t\t\tcase LEX_NUM:\r\n\t\t\t\tnextToken();\r\n\t\t\t\treturn eval(t);\r\n\t\t\tcase LEX_STR:\r\n\t\t\t\tnextToken();\r\n\t\t\t\treturn eval(t);\r\n\t\t\tcase LEX_STR2:\r\n\t\t\t\tnextToken();\r\n\t\t\t\treturn t.substr(1, t.length - 2).replace(/``/g, '`');\r\n\t\t\tcase LEX_OBRACKET:\r\n\t\t\t\tnextToken();\r\n\t\t\t\treturn parseArray([]);\r\n\t\t\tcase LEX_OBRACE:\r\n\t\t\t\tnextToken();\r\n\t\t\t\treturn parseObject({});\r\n\t\t\tcase LEX_BIND:\r\n\t\t\t\treturn parseBind();\r\n\t\t\tcase LEX_CONS:\r\n\t\t\t\tnextToken();\r\n\t\t\t\treturn eval(t);\r\n\t\t\tcase LEX_ID:\r\n\t\t\t\tnextToken();\r\n\t\t\t\tshift(LEX_OPAREN);\r\n\t\t\t\treturn parseConstruction(t, null);\r\n\t\t\tdefault:\r\n\t\t\t\terror(\"Expected value but got `\"+ t +\"` (token=\"+ token +\")!\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parseArray(array) {\r\n\t\tif (token !== LEX_CBRACKET) {\r\n\t\t\tparseElements(array);\r\n\t\t}\r\n\t\tshift(LEX_CBRACKET);\r\n\t\treturn array;\r\n\t}\r\n\r\n\tfunction parseObject(obj) {\r\n\t\tif (token !== LEX_CBRACE) {\r\n\t\t\tparseElements(obj);\r\n\t\t}\r\n\t\tshift(LEX_CBRACE);\r\n\t\treturn obj;\r\n\t}\r\n\r\n\tfunction parseElements(obj) {\r\n\t\tvar i = 0,\r\n\t\t\tt; \r\n\t\twhile (true) {\r\n\t\t\tt = text;\r\n\t\t\tswitch (token) {\r\n\t\t\t\tcase LEX_CONS:\r\n\t\t\t\t\tobj[i++] = eval(t);\r\n\t\t\t\t\tnextToken();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LEX_ID:\r\n\t\t\t\t\tswitch (nextToken()) {\r\n\t\t\t\t\t\tcase LEX_COLON:\r\n\t\t\t\t\t\t\tnextToken();\r\n\t\t\t\t\t\t\tif (t === '__proto__') {\r\n\t\t\t\t\t\t\t\t_setProto(obj, parseValue()); \r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tobj[t] = parseValue();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase LEX_OPAREN:\r\n\t\t\t\t\t\t\tnextToken();\r\n\t\t\t\t\t\t\tobj[i++] = parseConstruction(t, null);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\terror();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LEX_STR:\r\n\t\t\t\t\tif (nextToken() === LEX_COLON) {\r\n\t\t\t\t\t\tnextToken();\r\n\t\t\t\t\t\tif (t === '__proto__') {\r\n\t\t\t\t\t\t\t_setProto(obj, parseValue()); \r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tobj[eval(t)] = parseValue();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tobj[i++] = eval(t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LEX_NUM:\r\n\t\t\t\t\tobj[i++] = eval(t);\r\n\t\t\t\t\tnextToken();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LEX_BIND: \r\n\t\t\t\t\tobj[i++] = parseBind();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LEX_STR2:\r\n\t\t\t\tcase LEX_OBRACKET:\r\n\t\t\t\tcase LEX_OBRACE:\r\n\t\t\t\t\tobj[i++] = parseValue();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\terror(\"Expected element but got `\"+ t +\"` (token=\"+ token +\", input='\"+ input +\"')!\"); //FIXME\r\n\t\t\t}\r\n\t\t\tif (token === LEX_COMMA) {\r\n\t\t\t\tnextToken();\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn obj;\r\n\t}\r\n\r\n\tfunction parseBind() {\r\n\t\tvar id = text;\r\n\t\tnextToken();\r\n\t\tif (token === LEX_EQUAL) {\r\n\t\t\tif (bindings.hasOwnProperty(id)) {\r\n\t\t\t\terror(\"Binding \"+ id +\" cannot be reassigned\");\r\n\t\t\t}\r\n\t\t\tnextToken();\r\n\t\t\tswitch (token) {\r\n\t\t\t\tcase LEX_OBRACKET:\r\n\t\t\t\t\tnextToken();\r\n\t\t\t\t\treturn parseArray(bindings[id] = []);\r\n\t\t\t\tcase LEX_OBRACE:\r\n\t\t\t\t\tnextToken();\r\n\t\t\t\t\treturn parseObject(bindings[id] = {});\r\n\t\t\t\tcase LEX_ID:\r\n\t\t\t\t\tvar cons = text;\r\n\t\t\t\t\tnextToken();\r\n\t\t\t\t\tshift(LEX_OPAREN);\r\n\t\t\t\t\treturn bindings[id] = parseConstruction(cons, bindings[id] = sermat.construct(cons, null, null));\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn bindings[id] = parseValue();\r\n\t\t\t}\r\n\t\t} else if (bindings.hasOwnProperty(id)) {\r\n\t\t\treturn bindings[id];\r\n\t\t} else {\r\n\t\t\tvar rec = sermat.record(id.substr(1));\r\n\t\t\tif (rec) {\r\n\t\t\t\treturn rec.type;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new ReferenceError('Sermat.mat: '+ id +' is not defined!');\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parseConstruction(cons, obj) {\r\n\t\tvar args = [];\r\n\t\tif (token !== LEX_CPAREN) {\r\n\t\t\tparseElements(args);\r\n\t\t}\r\n\t\tshift(LEX_CPAREN);\r\n\t\treturn sermat.construct(cons, obj, args);\r\n\t}\r\n\t\r\n\t// parseStart\r\n\tnextToken();\r\n\tvar result = parseValue();\r\n\tshift(LEX_EOI);\r\n\treturn result;\r\n} // materialize","/** ## Utilities ###################################################################################\r\n\r\n*/\r\n\r\n/** `serializeAsProperties` is a generic way of serializing an object, by creating another object\r\nwith some of its properties. This method can be used to quickly implement a serializer function when\r\nthe constructor of the type can be called with an object.\r\n*/\r\nfunction serializeAsProperties(obj, properties, ownProperties) {\r\n\tvar result = {},\r\n\t\tfromArray = Array.isArray(properties),\r\n\t\tname;\r\n\tfor (var i in properties) {\r\n\t\tname = properties[i];\r\n\t\tif (!ownProperties || obj.hasOwnProperty(name)) {\r\n\t\t\tresult[fromArray ? name : i] = obj[name];\r\n\t\t}\r\n\t}\r\n\treturn [result];\r\n}\r\n\r\n/** `serializeWithConstructor` serializes the `obj` object with a list of properties inferred from\r\nthe `constructor`'s formal argument list.\r\n*/\r\nfunction serializeWithConstructor(constructor, obj) {\r\n\tvar str = constructor +'',\r\n\t\tcomps = /^function\\s*[\\w$]*\\s*\\(([^)]*)\\)\\s*\\{/.exec(str)\r\n\t\t|| /^\\(([^)]*)\\)\\s*=>/.exec(str);\r\n\tif (comps && comps[1]) {\r\n\t\treturn comps[1].split(/\\s*,\\s*/).map(function (k) {\r\n\t\t\treturn obj[k];\r\n\t\t});\r\n\t} else {\r\n\t\tthrow new TypeError(\"Cannot infer a serialization from constructor (\"+ constructor +\")!\");\r\n\t}\r\n}\r\n\r\n/** `materializeWithConstructor` is a generic way of creating a new instance of the given type\r\n`constructor`. Basically a new object is built using the type's prototype, and then the constructor\r\nis called on this object and the given arguments (`args`) to initialize it.\r\n\r\nThis method can be used to quickly implement a materializer function when only a call to a\r\nconstructor function is required. It is the default materialization when no method has been given\r\nfor a registered type.\r\n*/\r\nfunction materializeWithConstructor(constructor, obj, args) {\r\n\tif (!obj) {\r\n\t\tobj = Object.create(constructor.prototype);\r\n\t\tif (!args) {\r\n\t\t\treturn obj;\r\n\t\t}\r\n\t}\r\n\tconstructor.apply(obj, args);\r\n\treturn obj;\r\n}\r\n\r\n/** `sermat` is a shortcut to materialize a serialization of a value, e.g. to clone the value.\r\n*/\r\nfunction sermat(obj, modifiers) {\r\n\treturn this.mat(this.ser(obj, modifiers));\r\n}\r\n\r\n/** The `clone` function makes a deep copy of a value, taking advantage of Sermat's definitions. It\r\nis like `Sermat.sermat`, but without dealing with text.\r\n*/\r\nfunction clone(obj, modifiers) {\r\n\tvar sermat = this,\r\n\t\tvisited = [],\r\n\t\tcloned = [],\r\n\t\tuseConstructions = _modifier(modifiers, 'useConstructions', this.modifiers.useConstructions),\r\n\t\tautoInclude = _modifier(modifiers, 'autoInclude', this.modifiers.autoInclude),\r\n\t\tclimbPrototypes = _modifier(modifiers, 'climbPrototypes', this.modifiers.climbPrototypes);\r\n\r\n\tfunction cloneObject(obj) {\r\n\t\tvisited.push(obj);\r\n\t\tvar isArray = Array.isArray(obj),\r\n\t\t\tclonedObj;\r\n\t\tif (isArray || obj.constructor === Object || !useConstructions) {\r\n\t\t\tclonedObj = isArray ? [] : {};\r\n\t\t\tif (climbPrototypes) {\r\n\t\t\t\tvar objProto = _getProto(obj);\r\n\t\t\t\tif (!objProto.hasOwnProperty('constructor')) {\r\n\t\t\t\t\t_setProto(clonedObj, cloneObject(objProto));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcloned.push(clonedObj);\r\n\t\t\tObject.keys(obj).forEach(function (k) {\r\n\t\t\t\tclonedObj[k] = cloneValue(obj[k]);\r\n\t\t\t});\r\n\t\t} else { // Constructions.\r\n\t\t\tvar record = sermat.record(obj.constructor)\r\n\t\t\t\t|| autoInclude && sermat.include(obj.constructor);\r\n\t\t\tif (!record) {\r\n\t\t\t\tthrow new TypeError(\"Sermat.clone: Unknown type \\\"\"+\r\n\t\t\t\t\tsermat.identifier(obj.constructor) +\"\\\"!\");\r\n\t\t\t}\r\n\t\t\tclonedObj = record.materializer.call(sermat, null, null);\r\n\t\t\tcloned.push(clonedObj);\r\n\t\t\tvar clonedIdx = cloned.length - 1,\r\n\t\t\t\tclonedArgs = record.serializer.call(sermat, obj).map(cloneValue);\r\n\t\t\tclonedObj = record.materializer.call(sermat, clonedObj, clonedArgs);\r\n\t\t\t// In case the materializer does not support empty initialization.\r\n\t\t\tcloned[clonedIdx] = clonedObj;\r\n\t\t}\r\n\t\treturn clonedObj;\r\n\t}\r\n\r\n\tfunction cloneValue(value) {\r\n\t\tswitch (typeof value) {\r\n\t\t\tcase 'undefined':\r\n\t\t\tcase 'boolean':\r\n\t\t\tcase 'number':\r\n\t\t\tcase 'string':\r\n\t\t\tcase 'function':\r\n\t\t\t\treturn value;\r\n\t\t\tcase 'object':\r\n\t\t\t\tif (value === null) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\tvar i = visited.indexOf(value);\r\n\t\t\t\treturn i >= 0 ? cloned[i] : cloneObject(value);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error('Unsupported type '+ typeof value +'!');\r\n\t\t}\r\n\t}\r\n\r\n\treturn cloneValue(obj);\r\n}\r\n\r\n/** The `hashCode` function calculates an integer hash for the given value. It is mostly inspired by\r\nthe same method in Java objects.\r\n*/\r\nfunction hashCode(value, modifiers) {\r\n\tvar sermat = this,\r\n\t\tvisited = [],\r\n\t\thashCodes = [],\r\n\t\tuseConstructions = _modifier(modifiers, 'useConstructions', this.modifiers.useConstructions),\r\n\t\tautoInclude = _modifier(modifiers, 'autoInclude', this.modifiers.autoInclude),\r\n\t\tclimbPrototypes = _modifier(modifiers, 'climbPrototypes', this.modifiers.climbPrototypes);\r\n\r\n\tfunction hashObject(obj) {\r\n\t\tvar hash = 1,\r\n\t\t\thashIndex = visited.push(obj);\r\n\t\thashCodes.push(0);\r\n\t\tif (Array.isArray(obj) || obj.constructor === Object || !useConstructions) {\r\n\t\t\tif (climbPrototypes) {\r\n\t\t\t\tvar objProto = _getProto(obj);\r\n\t\t\t\tif (!objProto.hasOwnProperty('constructor')) {\r\n\t\t\t\t\thash = hashObject(objProto);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar hashes = [];\r\n\t\t\tfor (var k in obj) {\r\n\t\t\t\thashes.push(hashValue(k) ^ hashValue(obj[k]));\r\n\t\t\t}\r\n\t\t\thashes.sort(function (x,y) {\r\n\t\t\t\treturn x - y;\r\n\t\t\t}).forEach(function (x) {\r\n\t\t\t\thash = (31 * hash + x) |0;\r\n\t\t\t});\r\n\t\t} else { // Constructions.\r\n\t\t\tvar record = sermat.record(obj.constructor)\r\n\t\t\t\t|| autoInclude && sermat.include(obj.constructor);\r\n\t\t\tif (!record) {\r\n\t\t\t\tthrow new TypeError(\"Sermat.hashCode: Unknown type \\\"\"+ sermat.identifier(obj.constructor) +\"\\\"!\");\r\n\t\t\t}\r\n\t\t\treturn hashObject(record.serializer.call(sermat, obj));\r\n\t\t}\r\n\t\thashCodes[hashIndex] = hash;\r\n\t\treturn hash;\r\n\t}\r\n\r\n\tfunction hashValue(value) {\r\n\t\tvar i, len;\r\n\t\tswitch (typeof value) {\r\n\t\t\tcase 'undefined':\r\n\t\t\tcase 'boolean':\r\n\t\t\tcase 'number': return value >>> 0;\r\n\t\t\tcase 'string':\r\n\t\t\t\tvar result = 5381;\r\n\t\t\t\tfor (i = 0, len = value.length & 0x1F; i < len; i++) {\r\n\t\t\t\t\tresult = result * 33 ^ value.charCodeAt(i);\r\n\t\t\t\t}\r\n\t\t\t\treturn result >>> 0;\r\n\t\t\tcase 'function':\r\n\t\t\tcase 'object':\r\n\t\t\t\tif (value === null) {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t\ti = visited.indexOf(value);\r\n\t\t\t\treturn i >= 0 ? hashCodes[i] : hashObject(value);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error('Unsupported type '+ typeof value +'!');\r\n\t\t}\r\n\t}\r\n\r\n\treturn hashValue(value);\r\n}\r\n","/** ## Constructions for Javascript types ##########################################################\r\n\r\nOne of Sermat's most important features is extensible handling of custom types. But the library \r\nprovides some implementations for some of Javascript's base types.\r\n*/\r\n\r\n/** The `signature` function builds a string representing the types of the arguments (separated by\r\ncomma). For each value it is equal to `typeof value` if is not `'object'`, the empty string (for \r\n`null`) or the name of the value's constructor.\r\n\r\nIt can be used to quickly check a call to a materializer using a regular expression.\r\n*/\r\nfunction signature() {\r\n\tvar r = \"\", t, v;\r\n\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\tv = arguments[i];\r\n\t\tt = typeof v;\r\n\t\tif (i) {\r\n\t\t\tr += ',';\r\n\t\t}\r\n\t\tr += t === 'object' ? (v ? identifier(v.constructor) : '') : t;\r\n\t}\r\n\treturn r;\r\n}\r\n\r\n/** The `checkSignature` function checks the types of a call to a materializer using a regular\r\n\texpression to match the result of `signature`. This is a simple and quick way of making the\r\n\tmaterializer functions more secure.\r\n*/\r\nfunction checkSignature(id, regexp, obj, args) {\r\n\tvar types = signature.apply(this, [obj].concat(args));\r\n\tif (!regexp.exec(types)) {\r\n\t\tthrow new TypeError(\"Sermat.checkSignature: Wrong arguments for construction of \"+ id \r\n\t\t\t+\" (\"+ types +\")!\");\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n/** `Sermat.CONSTRUCTIONS` contains the definitions of constructions registered globally. At first \r\nit includes some implementations for Javascript's base types.\r\n*/\r\nvar CONSTRUCTIONS = {},\r\n\tFUNCTION_RE = /^(function\\s*[\\w$]*\\s*\\((?:\\s*[$\\w]+\\s*,?)*\\)\\s*\\{[\\0-\\uFFFF]*\\}|\\((?:\\s*[$\\w]+\\s*,?)*\\)\\s*=>\\s*[\\0-\\uFFFF]*)$/;\r\n[\r\n/** All `Boolean`, `Number`, `String`, `Object` and `Array` instances are serialized with their \r\n\tspecific syntax and never as constructions. These are added only for compatibility at \r\n\tmaterialization.\r\n*/\r\n\t[Boolean,\r\n\t\tfunction serialize_Boolean(obj) {\r\n\t\t\treturn _assign([obj.valueOf()], obj);\r\n\t\t},\r\n\t\tfunction materialize_Boolean(obj, args) {\r\n\t\t\treturn args && _assign(new Boolean(args.shift()), args);\r\n\t\t}\r\n\t],\r\n\t[Number,\r\n\t\tfunction serialize_Number(obj) {\r\n\t\t\treturn _assign([obj.valueOf()], obj);\r\n\t\t},\r\n\t\tfunction materialize_Number(obj, args) {\r\n\t\t\treturn args && _assign(new Number(args.shift()), args);\r\n\t\t}\r\n\t],\r\n\t[String,\r\n\t\tfunction serialize_String(obj) {\r\n\t\t\tvar r = [''+ obj.valueOf()],\r\n\t\t\t\tlen = obj.length;\r\n\t\t\tObject.keys(obj).forEach(function (k) {\r\n\t\t\t\tif ((k|0) - k !== 0) {\r\n\t\t\t\t\tr[k] = obj[k];\t\r\n\t\t\t\t} else if (+k < 0 || +k >= obj.length) {\r\n\t\t\t\t\tthrow new TypeError('Sermat.ser: Cannot serialize String instances with'\r\n\t\t\t\t\t\t+' integer properties (like <'+ k +'>)!');\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn r;\r\n\t\t},\r\n\t\tfunction materialize_String(obj, args) {\r\n\t\t\treturn args && _assign(new String(args.shift()), args);\r\n\t\t}\r\n\t],\r\n\t[Object,\r\n\t\tfunction serialize_Object(value) {\r\n\t\t\tthrow new TypeError(\"Sermat.ser: Object literals should not be serialized by a construction!\"); \r\n\t\t},\r\n\t\tfunction materialize_Object(obj, args) {\r\n\t\t\treturn args && Object.apply(null, args);\r\n\t\t}\r\n\t],\r\n\t[Array,\r\n\t\tfunction serialize_Array(value) {\r\n\t\t\tthrow new TypeError(\"Sermat.ser: Arrays should not be serialized by a construction!\"); \r\n\t\t},\r\n\t\tfunction materialize_Array(obj, args) {\r\n\t\t\treturn args;\r\n\t\t}\r\n\t],\r\n\r\n/** + `RegExp` instances are serialized with two arguments: a string for the regular expression and \r\n\ta string for its flags.\r\n*/\r\n\t[RegExp,\r\n\t\tfunction serialize_RegExp(value) {\r\n\t\t\tvar comps = /^\\/(.+?)\\/([a-z]*)$/.exec(value +'');\r\n\t\t\tif (!comps) {\r\n\t\t\t\traise('serialize_RegExp', \"Cannot serialize RegExp \"+ value +\"!\", { value: value });\r\n\t\t\t}\r\n\t\t\treturn _assign([comps[1], comps[2]], value);\r\n\t\t},\r\n\t\tfunction materialize_RegExp(obj, args /* [regexp, flags] */) {\r\n\t\t\treturn args && checkSignature('RegExp', /^(,string){1,2}$/, obj, args)\r\n\t\t\t\t&& _assign(new RegExp(args.shift(), args.shift()), args);\r\n\t\t}\r\n\t],\r\n\r\n/** + `Date` instances are serialized using its seven UTC numerical components (in this order): \r\n\tyear, month, day, hours, minutes, seconds and milliseconds.\r\n*/\r\n\t[Date,\r\n\t\tfunction serialize_Date(value) {\r\n\t\t\treturn _assign([value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), \r\n\t\t\t\tvalue.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), \r\n\t\t\t\tvalue.getUTCMilliseconds()], value);\r\n\t\t},\r\n\t\tfunction materialize_Date(obj, args /*[ years, months, days, hours, minutes, seconds, milliseconds ] */) {\r\n\t\t\tif (args && checkSignature('Date', /^(,number){1,7}?$/, obj, args)) {\r\n\t\t\t\treturn _assign(new Date(Date.UTC(args.shift() |0, +args.shift() || 1, \r\n\t\t\t\t\targs.shift() |0, args.shift() |0, args.shift() |0, args.shift() |0, \r\n\t\t\t\t\targs.shift() |0)), args);\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t],\r\n\r\n/** + `Function` is not registered by default, but it is available. Functions are serialized with\r\n\ttheir full source code, in order to support arrow functions and to include the function's name.\r\n*/\r\n\t[Function,\r\n\t\tfunction serialize_Function(f) {\r\n\t\t\tvar source = f +'',\r\n\t\t\t\tcomps = FUNCTION_RE.test(source);\r\n\t\t\tif (!comps) {\r\n\t\t\t\tthrow new TypeError(\"Could not serialize function (\"+ source +\")!\");\r\n\t\t\t}\r\n\t\t\treturn _assign([source], f);\r\n\t\t},\r\n\t\tfunction materialize_Function(obj, args) {\r\n\t\t\tif (args && checkSignature('Function', /^,string$/, obj, args)) {\r\n\t\t\t\tif (!FUNCTION_RE.test(args[0])) {\r\n\t\t\t\t\tthrow new ParseError('Invalid source for Function ('+ args[0] +')!');\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn _assign(eval('('+ args.shift() +')'), args);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t],\r\n\t\r\n/** + Error clases (`Error`, `EvalError`, `RangeError`, `ReferenceError`, `SyntaxError`, `TypeError` \r\n\tand `URIError`) are not registered by default, but are available. Error instances are serialized \r\n\twith their `name`, `message` and `stack`. The `stack` trace is overriden, since it is \r\n\tinitialized by the engine when the instance is created. Other properties are not considered, and \r\n\tmay become inconsistent (e.g. Firefox's `fileName` and `lineNumber`).\r\n*/\r\n\t[Error, serialize_Error, materializer_Error(Error)],\r\n\t[EvalError, serialize_Error, materializer_Error(EvalError)],\r\n\t[RangeError, serialize_Error, materializer_Error(RangeError)],\r\n\t[ReferenceError, serialize_Error, materializer_Error(ReferenceError)],\r\n\t[SyntaxError, serialize_Error, materializer_Error(SyntaxError)],\r\n\t[TypeError, serialize_Error, materializer_Error(TypeError)],\r\n\t[URIError, serialize_Error, materializer_Error(URIError)],\r\n].forEach(function (rec) {\r\n\tvar id = identifier(rec[0], true);\r\n\tmember(CONSTRUCTIONS, id, Object.freeze({\r\n\t\tidentifier: id,\r\n\t\ttype: rec[0],\r\n\t\tserializer: rec[1], \r\n\t\tmaterializer: rec[2]\r\n\t}), 1);\r\n});\r\n\r\n//FIXME Serialization does not consider own properties.\r\nfunction serialize_Error(obj) {\r\n\treturn [obj.message, obj.name || '', obj.stack || ''];\r\n}\r\n\r\nfunction materializer_Error(type) {\r\n\treturn function materialize_Error(obj, args) {\r\n\t\tvar r = null;\r\n\t\tif (args) {\r\n\t\t\tr = new type(args[0] +'');\r\n\t\t\tr.name = args[1] +'';\r\n\t\t\tr.stack = args[2] +'';\r\n\t\t}\r\n\t\treturn r;\r\n\t};\r\n}","/** ## Wrap-up #####################################################################################\r\n\r\nHere both `Sermat`'s prototype and singleton are set up. \r\n*/\r\nfunction Sermat(params) {\r\n\tvar __registry__ = {},\r\n\t\t__modifiers__ = {};\r\n\tmember(this, 'registry', __registry__);\r\n\tmember(this, 'register', register.bind(this, __registry__));\r\n\tmember(this, 'remove', remove.bind(this, __registry__));\r\n\t\r\n\tparams = params || {};\r\n\tmember(this, 'modifiers', __modifiers__);\r\n\tmember(__modifiers__, 'mode', _modifier(params, 'mode', BASIC_MODE), 5);\r\n\tmember(__modifiers__, 'onUndefined', _modifier(params, 'onUndefined', TypeError), 5);\r\n\tmember(__modifiers__, 'autoInclude', _modifier(params, 'autoInclude', true), 5);\r\n\tmember(__modifiers__, 'useConstructions', _modifier(params, 'useConstructions', true), 5);\r\n\tmember(__modifiers__, 'climbPrototypes', _modifier(params, 'climbPrototypes', true), 5);\r\n\t/** The constructors for Javascript's _basic types_ (`Boolean`, `Number`, `String`, `Object`, \r\n\t\tand `Array`, but not `Function`) are always registered. Also `Date` and `RegExp` are\r\n\t\tsupported by default.\r\n\t*/\r\n\tthis.include('Boolean Number String Object Array Date RegExp'.split(' '));\r\n}\r\n\r\nvar __members__ = {\r\n\tBASIC_MODE: BASIC_MODE,\r\n\tREPEAT_MODE: REPEAT_MODE,\r\n\tBINDING_MODE: BINDING_MODE,\r\n\tCIRCULAR_MODE: CIRCULAR_MODE,\r\n\tCONSTRUCTIONS: CONSTRUCTIONS,\r\n\t\r\n\tidentifier: identifier,\r\n\trecord: record,\r\n\tinclude: include,\r\n\texclude: exclude,\r\n\t\r\n\tserialize: serialize, ser: serialize,\r\n\tserializeAsProperties: serializeAsProperties,\r\n\tsignature: signature, checkSignature: checkSignature,\r\n\t\r\n\tmaterialize: materialize, mat: materialize,\r\n\tconstruct: construct,\r\n\tmaterializeWithConstructor: materializeWithConstructor,\r\n\t\r\n\tsermat: sermat, clone: clone, hashCode: hashCode\r\n};\r\nObject.keys(__members__).forEach(function (id) {\r\n\tvar m = __members__[id];\r\n\tmember(Sermat.prototype, id, m);\r\n});\r\n\r\n/** Sermat can be used as a constructor of serializer/materializer components as well as a \r\n\tsingleton. Each instance has a separate registry of constructors.\r\n*/\r\nvar __SINGLETON__ = new Sermat();\r\n\r\n/** The constructions for `Date` and `RegExp` are registered globally. \r\n*/\r\n__SINGLETON__.include(['Date', 'RegExp']);\r\n\r\nObject.keys(__members__).forEach(function (id) {\r\n\tvar m = __members__[id];\r\n\tmember(Sermat, id, typeof m === 'function' ? m.bind(__SINGLETON__) : m);\r\n});\r\n\r\n['registry', 'register', 'remove', 'modifiers'].forEach(function (id) {\r\n\tmember(Sermat, id, __SINGLETON__[id]);\r\n});\r\n\r\n/** Module layout.\r\n*/\r\nmember(Sermat, '__package__', 'sermat');\r\nmember(Sermat, '__name__', 'Sermat');\r\nmember(Sermat, '__init__', __init__, 4);\r\nmember(Sermat, '__dependencies__', [], 4);","/** See __prologue__.js\r\n*/\r\n\treturn Sermat;\r\n}"]}