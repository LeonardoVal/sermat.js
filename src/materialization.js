/** ## Materialization #############################################################################

The `materialize` method is similar to JSON's `parse` method. It takes text and parses it to produce
the data structure it represents.
*/

/** The `construct` method seeks for a materializer for the given identifier and calls it.
*/
function construct(id, obj, args) {
	var record = this.record(id);
	if (record) {
		return record.materializer.call(this, obj, args);
	} else {
		raise('construct', "Cannot materialize construction for '"+ id +"'", { invalidId: id });
	}
}

var EOL_RE = /\r\n?|\n/g,
/** The lexer is implemented with a big regular expression that combines all the regular 
	expressions of Sermat's lexemes. The function `String.replace` is used with a callback that 
	performs the actual parsing.
*/
	LEXER_RE = new RegExp([
		/\s+/, // whitespace (1)
		/\/\*(?:[\0-)+-.0-\uFFFF]*|\*+[\0-)+-.0-\uFFFF])*\*+\//, // block comment (2)
		/[a-zA-Z_\$][a-zA-Z0-9_]*(?:[.-][a-zA-Z0-9_]+)*/, // identifier (3)
		/[+-]Infinity|[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/, // numerals (4)
		/\"(?:[^\\\"]|\\[\0-\uFFFF])*\"/, // string literals (5)
		/[\[\]\{\}\(\):,=]/, // symbols (6)
		/.|$/ // error (7)
	].map(function (re) {
		re = re +'';
		return '('+ re.substr(1, re.length - 2) +')';
	}).join('|'), 'g'),
/** The parse table was calculated using [JS/CC](http://jscc.phorward-software.com/jscc/jscc.html).
	The generated parser is not used because of two reasons. First, the lexer generated by JS/CC
	is always limited to characters from `\x00` and `\xFF`. Second, because the way it is done here 
	results in less code, even after minimization.
*/
	PARSE_TABLE = [[,10,11,3,13,,12,,,,,,,2,4,5,6,7,8,9,1],
		[,,,,,,,,,,,,,,,,,,,,,,0],
		[,,,,,-1,,-1,,-1,,-1,,,,,,,,,,,-1],
		[,,,,,-9,,-9,15,-9,,-9,14,,,,,,,,,,-9],
		[,,19,18,,,,17,,,,,,,,,,,,,,16],
		[,,,,,,,21,,,,20],
		[,10,11,3,13,23,12,,,,,,,2,4,5,6,7,8,9,22],
		[,,,,,25,,,,,,24],
		[,10,11,3,13,,12,,,27,,,,2,4,5,6,7,8,9,26],
		[,,,,,,,,,29,,28],
		[,,,,,-10,,-10,,-10,,-10,,,,,,,,,,,-10],
		[,,,,,-11,,-11,30,-11,,-11,,,,,,,,,,,-11],
		[,,-13,-13,,,,-13],
		[,-19,-19,-19,-19,-19,-19],
		[,,31,34,33,,32],
		[,-23,-23,-23,-23,,-23,,,-23],
		[,,,,,,,,,,35],
		[,,,,,-3,,-3,,-3,,-3,,,,,,,,,,,-3],
		[,,,,,,,,,,-16],
		[,,,,,,,,,,-17],
		[,,19,18,,,,,,,,,,,,,,,,,,36],
		[,,,,,-4,,-4,,-4,,-4,,,,,,,,,,,-4],
		[,,,,,-20,,,,,,-20],
		[,,,,,-5,,-5,,-5,,-5,,,,,,,,,,,-5],
		[,10,11,3,13,,12,,,,,,,2,4,5,6,7,8,9,37],
		[,,,,,-6,,-6,,-6,,-6,,,,,,,,,,,-6],
		[,,,,,,,,,-26,,-26],
		[,,,,,-7,,-7,,-7,,-7,,,,,,,,,,,-7],
		[,10,11,3,13,,12,,,,,,,2,4,5,6,7,8,9,38],
		[,,,,,-8,,-8,,-8,,-8,,,,,,,,,,,-8],
		[,-25,-25,-25,-25,,-25,,,-25],
		[,,,,,-2,,-2,39,-2,,-2,,,,,,,,,,,-2],
		[,,-12,-12,,,,-12],
		[,-18,-18,-18,-18,-18,-18],
		[,,,,,,,,40],
		[,10,11,3,13,,12,,,,,,,2,4,5,6,7,8,9,41],
		[,,,,,,,,,,42],
		[,,,,,-21,,,,,,-21],
		[,,,,,,,,,-27,,-27],
		[,-24,-24,-24,-24,,-24,,,-24],
		[,-22,-22,-22,-22,,-22,,,-22],
		[,,,,,,,-14,,,,-14],
		[,10,11,3,13,,12,,,,,,,2,4,5,6,7,8,9,43],
		[,,,,,,,-15,,,,-15]
	],
/** Parsing a Sermat string literal uses `eval` after escaping all ends of lines.
*/
	parseString = function parseString(lit) {
		return eval.call(null, lit.replace(EOL_RE, function (match) {
			return match === '\n' ? '\\n' : match === '\r' ? '\\r' : '\\r\\n';
		}));
	};

function materialize(text) {
	/** Sermat's parser is LALR. It handles two stacks: the `stateStack` one for parsing states 
		and the `valueStack` for intermediate values. Bindings are used to resolve all values that
		appear as words (`true`, `null`, etc.).
	*/
	var construct = this.construct.bind(this),
		valueStack = new Array(50), 
		stateStack = new Array(50), 
		stackPointer = 0,
		bindings = { 'true': true, 'false': false, 'null': null, 'NaN': NaN, 'Infinity': Infinity },
		offset, result;
	stateStack[0] = 0;

	/** Unbound identifiers showing in the text always raise an error. Also, values cannot be rebound.
	*/
	var getBind = (function (id) {
		var value = bindings[id];
		if (typeof value === 'undefined') {
			parseError("'"+ id +"' is not bound", { unboundId: id });
		}
		return value;
	}).bind(this);

	function setBind(id, value) {
		if (id.charAt(0) != '$') {
			parseError("Invalid binding identifier '"+ id +"'", { invalidId: id });
		}
		if (bindings.hasOwnProperty(id)) {
			parseError("'"+ id +"' is already bound", { boundId: id });
		}
		return (bindings[id] = value);
	}
	
	/** The parser does not keep track of ends of lines. These are calculated when an error must
		be raised.
	*/
	function parseError(message, data) {
		data = data || {};
		data.offset = offset;
		var line = 0, lineStart = 0;
		text.substr(0, offset).replace(EOL_RE, function (match, pos) {
			lineStart = pos + match.length;
			line++;
			return '';
		});
		data.line = line + 1;
		data.column = offset - lineStart;
		raise('materialize', message +" at line "+ data.line +" column "+ data.column +" (offset "+ offset +")!", data);
	}

	/** Being an LALR parser, the _semantics_ is expressed in functions that are called when a reduce 
		actions is made. The following matches with the language's grammar.
	*/
	var ACTIONS = (function () { 
		function return$1($1) {
			return $1;
		}
		function cons($1, $2) {
			var obj = construct($1[1], $1[2], $1[3]);
			if ($1[2] && obj !== $1[2]) {
				parseError("Object initialization for "+ $1[1] +" failed", { oldValue: $1[2], newValue: obj });
			}
			return $1[0] ? setBind($1[0], obj) : obj;
		}
		return [null, // ACCEPT
		// `value : atom ;`
			[20, 1, return$1],
		// `value : 'id' '=' 'str' ;`
			[20, 3, function ($1,$2,$3) {
				return setBind($1, $3);
			}],
		// `value : obj0 '}' ;`
			[20, 2, return$1],
		// `value : obj1 '}' ;`
			[20, 2, return$1],
		// `value : array0 ']' ;`
			[20, 2, return$1],
		// `value : array1 ']' ;`
			[20, 2, return$1],
		// `value : cons0 ')' ;`
			[20, 2, cons],
		// `value : cons1 ')' ;`
			[20, 2, cons],
		// `atom : 'id' ;`
			[13, 1, function ($1) {
				return getBind($1);
			}],
		// `atom : 'num' ;`
			[13, 1, Number],
		// `atom : 'str' ;`
			[13, 1, parseString],
		// `obj0 : 'id' '=' '{' ;`
			[14, 3, function ($1,$2,$3) {
				return setBind($1, {});
			}],
		// `obj0 : '{' ;`
			[14, 1, function ($1) {
				return {};
			}],
		// `obj1 : obj0 key ':' value ;`
			[15, 4, function ($1,$2,$3,$4) {
				$1[$2] = $4;
				return $1;
			}],
		// `obj1 : obj1 ',' key ':' value ;`
			[15, 5, function ($1,$2,$3,$4,$5) {
				$1[$3] = $5;
				return $1;
			}],
		// `key : 'id' ;`
			[21, 1, return$1],
		// `key : 'str' ;`
			[21, 1, parseString],
		// `array0 : 'id' '=' '[' ;`
			[16, 3, function ($1,$2,$3) {
				return setBind($1, []);
			}],
		// `array0 : '[' ;`
			[16, 1, function ($1) {
				return [];
			}],
		// `array1 : array0 value ;`
			[17, 2, function ($1,$2) { 
				$1.push($2);
				return $1;
			}],
		// `array1 : array1 ',' value ;`
			[17, 3, function ($1,$2,$3) { 
				$1.push($3);
				return $1;
			}],
		// `cons0 : 'id' '=' 'id' '(' ;`
			[18, 4, function ($1,$2,$3,$4) {
				var obj = construct($3, null, null);
				return obj ? [null, $3, setBind($1, obj), []] : [$1, $3, obj, []];
			}],
		// `cons0 : 'id' '(' ;`
			[18, 2, function ($1,$2,$3) {
				return [null, $1, null, []];
			}],
		// `cons0 : 'id' '=' 'str' '(' ;`
			[18, 4, function ($1,$2,$3,$4) {
				$3 = parseString($3);
				var obj = construct($3, null, null);
				return obj ? [null, $3, setBind($1, obj), []] : [$1, $3, obj, []];
			}],
		// `cons0 : 'str' '(' ;`
			[18, 2, function ($1,$2,$3) {
				return [null, parseString($1), null, []];
			}],
		// `cons1 : cons0 value ;`
			[19, 2, function ($1,$2) {
				return ($1[3].push($2), $1);
			}],
		// `cons1 : cons1 ',' value ;`
			[19, 3, function ($1,$2,$3) {
				return ($1[3].push($3), $1);
			}]
		];
	})();
	
	/** The actual parser is implemented with the `String.replace` method with a regular expression
		and a function callback. The regular expression deals with all language's lexemes. The 
		function callback handles the parser's stacks.
	*/
	text.replace(LEXER_RE, function (match, $wsp, $comm, $id, $num, $str, $sym, $err, _offset) {
		if ($wsp || $comm) {
			return ''; // Ignore whitespace and comments.
		}
		offset = _offset;
		var symbol = $num ? 1 : $str ? 2 : $id ? 3 : $sym ? '[]{}():,='.indexOf($sym) + 4 : $err ? 23 /* ERROR */ : 22 /* EOF */,
			parseAction, action;
		while (true) {
			parseAction = PARSE_TABLE[stateStack[stackPointer]][symbol];
			if (parseAction < 0) {
				action = ACTIONS[-parseAction];
				if (action) { // reduce
					stackPointer += 1 - action[1];
					valueStack[stackPointer] = action[2].apply(null, valueStack.slice(stackPointer, stackPointer + action[1]));
					stateStack[stackPointer] = PARSE_TABLE[stateStack[stackPointer - 1]][action[0]]; // GOTO action.
					continue;
				}
			} else if (parseAction > 0) { // shift
				stateStack[++stackPointer] = parseAction;
				valueStack[stackPointer] = match;
				return '';
			} else if (parseAction == 0) { // accept.
				result = valueStack[stackPointer];
				return '';
			}
			parseError("Parse error");
		}
	});
	return result;
}